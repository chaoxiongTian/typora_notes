### Java 复习基础

1. 数据类型：由低到高

```java
(byte,char,short)-->int-->float-->long-->double-->boolean
类型转换
1. 强制类型转换:我就是要这么干（大转小）（精度遗失）
2. 自动类型转换:（隐式转化）只能从小到大进行，无法逆。
```

2. 数组类型，和对应字节。

```java
    byte      1字节  8位
    boolean          1位
    char      2字节  16位
    short     2字节  16位
    int       4字节  32位
    float     4字节  32位
    long      8字节  64位
    double    8字节  64位
```

3. 栈内存堆内存

```java
堆内存,栈内存的区别:
 1.栈内存运行速度快
 2.堆内存体积大
 3.栈内存主要存放基本数据类型,堆内存主要存放引用数据类型

1.基本数据类型: 
 byte,char,short,int,float,long,double,boolean
2.引用数据类型: 对象类型
3.数组

堆区: 
1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)
2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 
栈区:
1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中
2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。 
3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 
方法区: 
1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 
2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。
```

4. 变量

```java
 	 * 局部变量：定义在方法体内部的属于局部变量, 
     * 解释：这个变量只能在自身方法体内使用 一旦方法执行完成，局部变量自动销毁(如果方法是静态方法，该局部变量不会销毁) (存放于栈内存中)
     * 成员变量: 作用于整个类 (存放于堆内存中)
     * 静态变量：作用于整个包 
```

5. 运算符

```java
// + 的使用场景
1. 在加法是把左右两边的数据转换成二进制进行运算的。
2. 在字符串作为字符串连接符，不进行二进制转换。（字符串与任何数据类型进行+,结果都涉及字符串类型）
// i++ ， ++i
1. j = i++; //先把i赋值给j,然后i自增1.
2. j = ++i; //i先自动增1，然后赋值给j.
// 逻辑运算符
      * & : 一假为假
      * | : 一真为真
      * ^ : 相同为假，不同为真
      * && : 前面的为真时，后面的不执行
      * || : 前面的为真时，后面的不执行
      * << : 左移位 运算速率快，但是只能乘以2的n次方 （6<<n）---->n代表2的几次方
      * >> : 右移位 运算速率快，但是只能除以2的n次方（这是整形之间的运算，需要取整）
```

6. do while 和while

```java
do while 至少会执行一次。
while 则可以一次都不执行。
```

7. 匿名对象

```java
// 1 什么是匿名对象。
new Person().showMessage(); // 匿名对象

Person p = new Person(); // 非匿名对象 
p.name = "蛋蛋";  
p.age = 6;  
p.height = 1.1;  
p.showMessage(); 
不用实例化一个引用对象而是用其方法叫做匿名对象。
// 2 匿名对象的和声明对象的区别。
1）赋值范围
    //非匿名对象  
    Person p = new Person();  
    p.name = "蛋蛋";  
    p.age = 6;  
    p.height = 1.1; 
	非匿名对象是给一个对象p的三个属性进行赋值。
    //匿名对象  
    new Perosn.name = "花花";  
    new Perosn.age = 21;  
    new Perosn.height = 1.2;  
	匿名对象是给三个不同对象的三个属性进行分别赋值。
2）内存情况
非匿名对象声明之后在堆内存中则有一块区域。
匿名对象声明之后堆内存中有三块区域，使用完之后java垃圾回收机制，将其回收。
// 3 匿名对象适用场景。
1）类中方法只被调用一次。
new Person().showMessage(); // 调用一次。
2) 作为实参进行传递。
Person.show(new Person());  //匿名对象做实际参数
```

8. 封装

```java
// 封装：是指对用户隐藏实例实现的细节，仅提供公共访问的方式
// 作用：
1. 安全性高
2. 复用性高
3. 便于使用
4. 隔离变化
// 封装的原则:将大量重复且不需要对外界提供的内容隐藏起来,只提供公共访问方法.
```

9. 静态变量与非静态变量.

```java
// 静态变量
static关键字修饰的的变量,叫做类变量或者静态变量.
没有static修饰的叫做成员变量.
java虚拟机在加载类时,遇到静态变量即为其分配内存,该内存位于方法区,被类的所有实例共享.静态变量可以直接通过类名点变量进行访问,其声明周期取决于类的声明周期.
// 静态变量与非静态变量的区别
1. 存放位置不同.
2. 声明周期长短不同.
3. 静态成员变量生命周期比非静态成员变量长
// 什么时候使用静态
1.当几个对象之间具体共享的成员的时候
2.当几个对像在初始化已经具备某些相同的属性或行为
// 优势与缺点
优势:节省内存(单独的放在方法区,不销毁);方法使用,所以用类名点静态变量可进行调用
缺点:访问的局限性,静态方法只能调用静态变量.
```

10. 静态方法和非静态方法.

```java
//静态方法
使用static定义的方法.
静态方法会随着类的定义而被分配和装载入内存中.
而非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段.
// 注意点:
非静态方法既可以访问静态数据成员 又可以访问非静态数据成员，而静态方法只能访问静态数据成员；
原因:因为静态方法和静态数据成员会随着类的定义而被分配和装载入内存中，而非静态方法和非静态数据成员只有在类的对象创建时在对象的内存中才有这个方法的代码段。
```

11. 继承

```java
// 什么继承
子类获得父类除了private之外的所有方法属性.
//进程的好处
1. 提高代码的复用性.
2. 为了多态的使用?..?
// 注意点
super:代表父类的对象.
this:代表子类的方法.
特殊情况:父类和子类没有同名成员时，使用super和this都是指父类对象
加载子类的.class文件之前会优先加载父类的.class文件
```

12. 构造方法

```java
在子类构造方法中会默认添加一个隐式语句,super();回调父类的构造函数
子类中每个构造函数都调用了一次父类的构造函数super();
为什么Java要这么干：在子类创建对象之前，必须明确父类初始化的内容，防止安全隐患
用了this()，super就不会默认被添加，因为代码最终还是会走super()。
super()必须出现在构造函数的第一行。
this()回调本类空参构造;
```

13. 抽象类(abstract)

```java
//1 抽象类的概念
简单地说，抽象类是用abstract关键字声明的类。它可能包含或不包含任何抽象方法。JVM将抽象类标识为不完全的类，没有定义它完整的行为。声明类抽象导致一件事：您不能创建这个类的实例，就是这样。

```

> 1 抽象类的概念
> 简单地说，抽象类是用**abstract**关键字声明的类。它可能包含或不包含任何抽象方法。JVM将抽象类标识为**不完全的类**，没有定义它完整的行为。声明类抽象导致一件事：您不能创建这个类的实例，就是这样。

14. 接口

```java

```

15. 抽象类和接口异同点.

```java

```

