---
typora-copy-images-to: ..\..\pic
---

### Java 复习基础

1. 数据类型：由低到高

```java
(byte,char,short)-->int-->float-->long-->double-->boolean
类型转换
1. 强制类型转换:我就是要这么干（大转小）（精度遗失）
2. 自动类型转换:（隐式转化）只能从小到大进行，无法逆。
```

2. 数组类型，和对应字节。

```java
boolean          1位    
byte      1字节  8位
char      2字节  16位
short     2字节  16位
int       4字节  32位
float     4字节  32位
long      8字节  64位
double    8字节  64位
```

3. 栈内存堆内存

```java
堆内存,栈内存的区别:
 1.栈内存运行速度快
 2.堆内存体积大
 3.栈内存主要存放基本数据类型,堆内存主要存放引用数据类型

1.基本数据类型: 
 byte,char,short,int,float,long,double,boolean
2.引用数据类型: 对象类型
3.数组

堆区: 
1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)
2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 
栈区:
1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中
2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。 
3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 
方法区: 
1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 
2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。
class demo {
    private int var1; // 字段1
    private Integer var2; // 字段2
    public static void main(String[] args) {
        int var3 = 0; // 变量1
        demo obj1 = new demo(); // 实例1
    }
}
堆内存是属于JVM的，栈内存是属于方法的，方法结束了，栈内存也就没了。
程序运行main函数时，有一个堆内存，一个main的栈内存
int var3 = 0；
这个var3，是放在main函数的栈内存中的，是一个值。
demo obj1 = new demo();
main函数的栈内存中有了一个引用变量，obj1，指向了堆内存中new出来的这个实例。
我们再看堆内存中的这个实例，他有2个字段，他们都是存放在堆中的。
等到main函数运行结束时，假如还有别的线程在运行，JVM还没有结束，此时，main函数的栈内存被清除，var3，不在了，obj1这个引用变量也不在了，但是堆内存中的那个实例依然在，如果没有别的引用变量指向它 ，那么它将在稍后被清除。

针对数组:
1.看待数组时，要把数组看成两部分：一部分是数组引用，即在代码中定义的数组引用变量；另一部分是实际的数组对象，这部分是在堆内存里运行的，通常无法直接访问，只能通过数组引用变量来访问。
2.定义并初始化一个数组之后，在内存中分配了两个空间，一个用于存放数组的引用变量，另一个用于存放引用变量所指向的数组本身。
```

4. 变量

```java
局部变量：定义在方法体内部的属于局部变量, 
解释：这个变量只能在自身方法体内使用 
一旦方法执行完成，局部变量自动销毁(存放于栈块中)
(如果方法是静态方法(存放在方法块中)，该局部变量不会销毁) 
成员变量: 作用于整个类 (存放于堆内存中)
静态变量：作用于整个包 
```

5. 运算符

```java
// + 的使用场景
1. 在加法是把左右两边的数据转换成二进制进行运算的。
2. 在字符串作为字符串连接符，不进行二进制转换。
（字符串与任何数据类型进行+,结果都涉及字符串类型）
// i++ ， ++i
1. j = i++; //先把i赋值给j,然后i自增1.
2. j = ++i; //i先自动增1，然后赋值给j.
// 逻辑运算符
      * & : 一假为假
      * | : 一真为真
      * ^ : 相同为假，不同为真
      * && : 前面的为真时，后面的不执行
      * || : 前面的为真时，后面的不执行
      * << : 左移位 运算速率快，但是只能乘以2的n次方 （6<<n）---->n代表2的几次方
      * >> : 右移位 运算速率快，但是只能除以2的n次方（这是整形之间的运算，需要取整）
```

6. do while 和while

```java
do while 至少会执行一次。
while 则可以一次都不执行。
```

7. 匿名对象

```java
// 1 什么是匿名对象。
new Person().showMessage(); // 匿名对象

Person p = new Person(); // 非匿名对象 
p.name = "蛋蛋";  
p.age = 6;  
p.height = 1.1;  
p.showMessage(); 
不用实例化一个引用对象而是用其方法叫做匿名对象。
// 2 匿名对象的和声明对象的区别。
1）赋值范围
    //非匿名对象  
    Person p = new Person();  
    p.name = "蛋蛋";  
    p.age = 6;  
    p.height = 1.1; 
	非匿名对象是给一个对象p的三个属性进行赋值。
    //匿名对象  
    new Perosn.name = "花花";  
    new Perosn.age = 21;  
    new Perosn.height = 1.2;  
	匿名对象是给三个不同对象的三个属性进行分别赋值。
2）内存情况
非匿名对象声明之后在堆内存中则有一块区域。
匿名对象声明之后堆内存中有三块区域，使用完之后java垃圾回收机制，将其回收。
// 3 匿名对象适用场景。
1）类中方法只被调用一次。
new Person().showMessage(); // 调用一次。
2) 作为实参进行传递。
Person.show(new Person());  //匿名对象做实际参数
```

8. 封装

```java
// 封装：是指对用户隐藏实例实现的细节，仅提供公共访问的方式
// 作用：
1. 安全性高
2. 复用性高
3. 便于使用
4. 隔离变化
// 封装的原则:将大量重复且不需要对外界提供的内容隐藏起来,只提供公共访问方法.
```

9. 静态变量与非静态变量.

```java
// 静态变量
static关键字修饰的的变量,叫做类变量或者静态变量.
没有static修饰的叫做成员变量.
java虚拟机在加载类时,遇到静态变量即为其分配内存,该内存位于方法区,该类的所有实例共享.
静态变量可以直接通过(类名.变量)进行访问,其声明周期取决于类的声明周期.
// 静态变量与非静态变量的区别
1. 存放位置不同.
2. 声明周期长短不同.
3. 静态成员变量生命周期比非静态成员变量长
// 什么时候使用静态
1.当几个对象之间具体共享的成员的时候
2.当几个对像在初始化已经具备某些相同的属性或行为
// 优势与缺点
优势:节省内存(单独的放在方法区,不销毁);方法使用,所以用类名点静态变量可进行调用
缺点:访问的局限性,静态方法只能调用静态变量.
```

10. 静态方法和非静态方法.

```java
//静态方法
使用static定义的方法.
静态方法会随着类的定义而被分配和装载入内存中.
非静态方法属于对象的具体实例，只有在类的对象创建时在对象的内存中才有这个方法的代码段.
// 注意点:
非静态方法既可以访问静态数据成员又可以访问非静态数据成员，而静态方法只能访问静态数据成员；
原因:(加载到内存的时间不同,静态早于非静态,所以静态调用非静态报错)
因为静态方法和静态数据成员会随着类的定义而被分配和装载入内存中，
而非静态方法和非静态数据成员只有在类的对象创建时在对象的内存中才有这个方法的代码段。
```

11. 继承

```java
// 什么继承
子类获得父类除了private之外的所有方法属性.
//进程的好处
1. 提高代码的复用性.
2. 为了多态的使用?..?
// 注意点
super:代表父类的对象.
this:代表子类的方法.
特殊情况:父类和子类没有同名成员时，使用super和this都是指父类对象
加载子类的.class文件之前会优先加载父类的.class文件
```

12. 构造方法

```java
在子类构造方法中会默认添加一个隐式语句,super();回调父类的构造函数
子类中每个构造函数都调用了一次父类的构造函数super();
为什么Java要这么干：
在子类创建对象之前，必须明确父类初始化的内容，防止安全隐患
用了this()，super就不会默认被添加，因为代码最终还是会走super()。
super()必须出现在构造函数的第一行。
this()回调本类空参构造;
```

13. 抽象类(abstract)

```java
//1 抽象类的概念
简单地说，抽象类是用abstract关键字声明的类,它可能包含或不包含任何抽象方法。
JVM将抽象类标识为不完全的类，没有定义它完整的行为。
声明类抽象导致一件事：您不能创建这个类的实例，就是这样。
abstract class TestAbstractClass //在类中使用抽象方法将迫使您将类本身声明为抽象。
{
  	// 抽象方法
    public abstract void abstractMethod();
    // 非抽象方法
  	public void normalMethod()
    {
        //method body
    }
}
抽象方法，是一种没有实现的方法。
抽象方法以不完整性的形式添加到类中，因此编译器希望声明整个类为抽象。
//在应用程序中使用抽象类的唯一方法是继承这个类。
它的子类如果不能再次声明抽象，那么可以实例化。(子类实现抽象方法,即可摆脱抽象)
子类继承超类的行为，子类可以实现抽象方法。
```

14. 接口

```java
//接口定义了实现类需要遵守的契约。这些契约本质上是未实现的方法。
Java已经提供的任何类都可以实现任何接口。
// 所有接口中声明的方法只能是public
public interface TestInterface
{
    void implementMe();
}
针对上面的接口，任何实现类需要实现implementMe()方法。
//只有一种情况例外，当您实现一个接口时不需要实现接口的方法，即声明实现类本身抽象。
public abstract class TestMain implements TestInterface
{
    //No need to override implement Me
}
否则，你必须在你的类中实现implementMe ()方法。
public class TestMain implements TestInterface
{
    @Override
    public void implementMe() {
        // TODO Auto-generated method stub
    }
}
```

15. 抽象类和接口异同点.

```java
1. 接口所有方法都具有public和abstract。
您不能通过试图减少方法的可访问性来覆盖此行为。
您甚至不能声明静态（static）方法。只有public和abstract。
另一方面，抽象类在声明方法时是灵活的。
您还可以定义protected的抽象方法。
此外，还可以定义静态方法，前提是它们不是抽象的。允许使用非抽象静态方法。
2. 接口不能有完全定义的方法。根据定义，接口仅用于提供契约。
抽象类可以有非抽象的方法，没有任何限制。
您可以使用任何非抽象方法的关键字，就像在其他类中一样。
3. 任何抽象类可以用extends关键字继承抽象类，用implements关键字实现接口。
一个类只能继承一个类，但可以实现任意数量的接口。Java用此特性模拟多继承。
4. 接口是完全抽象的，不能被实例化；Java抽象类也不能实例化，但可以被调用，如果main()存在。 
```

16. 多态

```java
1. 多态的体现方面：
我们使用多态的时候，创建的是父类的引用，开辟的是子类的空间.
由于没有开辟父类的空间，所以是父类的引用指向子类对象，并不是真正的父类自己创建了对象.
而且父类对象的引用还可以作为函数参数来接收子类对象哦！
2. 多态实现的前提:
必须是类与类之间要有关系，要么继承，要么实现，存在覆盖，其实就是有抽象函数。
3. 从多态的好处:
大大提高程序的可拓展性
4. 多态的应用：
父类对象的引用指向子类对象，其实本质上是一个向上转型，就像int转成double一样，儿子穿了一身爸爸的衣服，扮成了爸爸。
但变成了爸爸之后，只能使用爸爸特有的技能，儿子怎么能够使用自己本身的技能呢？
这时候就需要向下转型，脱下伪装，将父类对象的引用强转成子类类型，就可以使用子类特有的技能了。
```

```java
//实例
三大前提:要有继承关系 子类要重写父类的方法 父类引用指向子类对
```

```java
父类Animal
class Animal {
	int num = 10;
	static int age = 20;
	public void eat() {
		System.out.println("动物吃饭");
	}
	public static void sleep() {
		System.out.println("动物在睡觉");
	}
	public void run(){
		System.out.println("动物在奔跑");
	}
}
```

```java
子类Cat
class Cat extends Animal {
	int num = 80;
	static int age = 90;
	String name = "tomCat";
	public void eat() {
		System.out.println("猫吃饭");
	}
	public static void sleep() {
		System.out.println("猫在睡觉");
	}
	public void catchMouse() {
		System.out.println("猫在抓老鼠");
	}
}
```

```java
测试类Demo_Test1
class Demo_Test1 {
public static void main(String[] args){
	Animal am = new Cat();
	am.eat();
	am.sleep();
	am.run();
	//am.catchMouse(); //无法调用子类方法
	//System.out.println(am.name);//无法调用子类成员变量
	System.out.println(am.num);
	System.out.println(am.age);
	}
}
```

```java
输出:
猫吃饭
动物在睡觉
动物在奔跑
10
20
```

17.  java程序运行的过程.

```java
Java程序从源文件创建到程序运行要经过两大步骤：
1. 源文件由编译器编译成字节码（ByteCode）；
2. 字节码由java虚拟机解释运行。
//编译
编译过程中会顺带编译类的依赖类，如果能找到则编译，不能找到报错。
编译好之后的.class有两部分组成常量池和方法的字节码。
常量池中包括：常量，类名，成员变量。
方法的字节码中包括：类的引用，方法的引用，成员变量的引用。
// 运行
解释执行分类两步: 类的加载 类的执行.
类的加载:执行java类名,系统会启动一个jvm进程,jvm从classpath中找到类名.class,
将类中的信息加载到运行时数据区的方法区中,这一过程叫做类的加载.
类的运行:先找到main方法,持有一个指向当前类常量池的指针,然后依次执行代码.
若遇到新的对象声明,JVM则创建一个新的此对象,并将其类信息加载到数据区域中.
```

18. 内部类:一个类定义在另一个类内部.

```java
// 内部类的四种形式:
1. 成员内部类
成员内部类，就是作为外部类的成员，可以直接使用外部类的所有成员和方法，即使是private的。
外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问(可用限定符来修饰,如果用private则只有外部类能调用)
2. 局部内部类
外部类的方法中再生成一个内部类对象去调用内部类方法。如果此时我们需要往外部类的方法中传入参数，那么外部类的方法形参必须使用final定义。
3. 静态嵌套内部类
声明为static的内部类，不需要内部类对象和外部类对象之间的联系，就是说我们可以直接引用outer.inner，即不需要创建外部类，也不需要创建内部类。
如果用static 将内部内静态化，那么内部类就只能访问外部类的静态成员变量，具有局限性。
4. 匿名内部类
匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。
```

[详细解释](https://www.cnblogs.com/hasse/p/5020519.html)

19. 进程和线程


```
进程：是由系统创建的一个活动单元
线程：进程运行的最小单元，是由系统创建
线程的状态：
1. 被创建
2. 运行
3. 睡眠
4. 等待
5. 阻塞
6. 销毁
```



19. final用法


````java
1. 用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。
对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；
2. 用来修饰方法参数，表示在变量的生存期中它的值不能被改变；
3. 修饰方法，表示该方法无法被重写；
4. 修饰类，表示该类无法被继承。
上面的四种方法中，第三种和第四种方法需要谨慎使用，
因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。
````

final详解[文章地址](https://www.cnblogs.com/dotgua/p/6357951.html)

